<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XAI-Powered DDoS Mitigation System - Animated Architecture</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a2a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: #fff;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            text-align: center;
            background: linear-gradient(90deg, #00d4ff, #7c3aed, #f472b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1rem;
            color: #888;
            margin-bottom: 20px;
            text-align: center;
        }

        .canvas-container {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 25px 80px rgba(0, 212, 255, 0.15),
                        0 10px 40px rgba(124, 58, 237, 0.1);
        }

        canvas {
            display: block;
            background: linear-gradient(180deg, #0d0d1a 0%, #1a1a2e 100%);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 28px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00d4ff 0%, #0099cc 100%);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff4757 0%, #cc0022 100%);
            color: #fff;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 71, 87, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #2ed573 0%, #1e8449 100%);
            color: #fff;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(46, 213, 115, 0.4);
        }

        .legend {
            display: flex;
            gap: 25px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
            color: #ccc;
        }

        .legend-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
        }

        .stats {
            display: flex;
            gap: 25px;
            margin-top: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stat-box {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px 25px;
            text-align: center;
            min-width: 130px;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(90deg, #00d4ff, #7c3aed);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
            margin-top: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }


    </style>
</head>
<body>
    <h1>üõ°Ô∏è Detection to Defense: XAI-Powered DDoS Mitigation</h1>
    <p class="subtitle">Complete System Flow - Animated Visualization</p>

    <div class="canvas-container">
        <canvas id="canvas" width="1200" height="1050"></canvas>
    </div>

    <div class="controls">
        <button class="btn btn-primary" onclick="toggleAnimation()">‚èØÔ∏è Pause / Resume</button>
        <button class="btn btn-danger" onclick="simulateAttack()">‚ö° Simulate Attack Wave</button>
        <button class="btn btn-success" onclick="resetStats()">üîÑ Reset Statistics</button>
    </div>

    <div class="legend">
        <div class="legend-item">
            <div class="legend-dot" style="background: #00ff88;"></div>
            <span>Normal Traffic</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #ff4444;"></div>
            <span>Attack Packet</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #ffaa00;"></div>
            <span>Unknown ‚Üí ML</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #aa66ff;"></div>
            <span>XAI Analysis</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background: #00d4ff;"></div>
            <span>Rule Update</span>
        </div>
    </div>

    <div class="stats">
        <div class="stat-box">
            <div class="stat-value" id="totalPackets">0</div>
            <div class="stat-label">Total Packets</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="bpfBlocked">0</div>
            <div class="stat-label">BPF Blocked</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="mlDetected">0</div>
            <div class="stat-label">ML Detected</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="allowed">0</div>
            <div class="stat-label">Allowed</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="rulesCreated">0</div>
            <div class="stat-label">Rules Created</div>
        </div>
    </div>



    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Center X for main flow
        const centerX = 600;

        // Y positions matching the vertical flow
        const yPositions = {
            internet: 40,
            bpf: 160,
            bpfSplit: 270,
            blockKnown: 360,
            ml: 450,
            mlSplit: 560,
            allowNormal: 650,
            xai: 740,
            mitigation: 880,
            mitigationSplit: 970,
            feedback: 1020
        };

        // X offsets for branches
        const leftBranchX = 280;
        const rightBranchX = 920;

        // Stats
        let stats = {
            totalPackets: 0,
            bpfBlocked: 0,
            mlDetected: 0,
            allowed: 0,
            rulesCreated: 0
        };

        // Animation state
        let isRunning = true;
        let knownPatterns = 2;
        let attackMode = false;
        let attackModeTimer = 0;

        // Packets
        let packets = [];

        // Background particles
        let bgParticles = [];

        // Packet class with CORRECT PATH FOLLOWING
        class Packet {
            constructor() {
                this.x = centerX;
                this.y = yPositions.internet + 50;
                this.radius = 7;
                this.speed = 3;
                
                const rand = Math.random();
                if (attackMode) {
                    this.isAttack = rand < 0.7;
                } else {
                    this.isAttack = rand < 0.3;
                }
                
                this.isKnownPattern = this.isAttack && Math.random() < (knownPatterns / 15);
                
                this.phase = 'toBPF';
                this.color = this.isAttack ? '#ff4444' : '#00ff88';
                this.trail = [];
                this.alpha = 1;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }

            update() {
                this.trail.push({ x: this.x, y: this.y, alpha: 0.7 });
                if (this.trail.length > 15) this.trail.shift();
                this.trail.forEach(t => t.alpha *= 0.85);
                this.pulsePhase += 0.15;

                switch (this.phase) {
                    // ===== INTERNET TO BPF =====
                    case 'toBPF':
                        this.y += this.speed;
                        if (this.y >= yPositions.bpf + 40) {
                            this.phase = 'inBPF';
                            stats.totalPackets++;
                            updateStats();
                        }
                        break;

                    // ===== INSIDE BPF - GOING TO SPLIT =====
                    case 'inBPF':
                        this.y += this.speed;
                        if (this.y >= yPositions.bpfSplit) {
                            if (this.isKnownPattern) {
                                // Known attack - go LEFT to BLOCK
                                this.phase = 'bpfGoLeft';
                                this.color = '#ff0000';
                            } else {
                                // Unknown - go RIGHT first, then down to ML
                                this.phase = 'bpfGoRight';
                                this.color = '#ffaa00';
                            }
                        }
                        break;

                    // ===== KNOWN ATTACK: GO LEFT TO BLOCK =====
                    case 'bpfGoLeft':
                        // Move horizontally left
                        if (this.x > leftBranchX + 5) {
                            this.x -= this.speed * 1.5;
                        } else {
                            this.phase = 'bpfGoDownToBlock';
                        }
                        break;

                    case 'bpfGoDownToBlock':
                        // Move down to BLOCK box
                        this.y += this.speed;
                        if (this.y >= yPositions.blockKnown) {
                            this.phase = 'blocked';
                            stats.bpfBlocked++;
                            updateStats();
                        }
                        break;

                    // ===== UNKNOWN TRAFFIC: GO RIGHT, THEN DOWN, THEN LEFT TO ML =====
                    case 'bpfGoRight':
                        // Move horizontally right
                        if (this.x < rightBranchX - 5) {
                            this.x += this.speed * 1.5;
                        } else {
                            this.phase = 'rightGoDownToML';
                        }
                        break;

                    case 'rightGoDownToML':
                        // Move down along right side
                        this.y += this.speed;
                        if (this.y >= yPositions.ml) {
                            this.phase = 'rightGoLeftToML';
                        }
                        break;

                    case 'rightGoLeftToML':
                        // Move left to enter ML box
                        if (this.x > centerX + 5) {
                            this.x -= this.speed * 1.5;
                        } else {
                            this.x = centerX;
                            this.phase = 'inML';
                        }
                        break;

                    // ===== INSIDE ML - GOING TO SPLIT =====
                    case 'inML':
                        this.y += this.speed;
                        if (this.y >= yPositions.mlSplit) {
                            if (this.isAttack) {
                                // Attack detected - go RIGHT, then down to XAI
                                this.phase = 'mlGoRight';
                                this.color = '#aa66ff';
                                stats.mlDetected++;
                                updateStats();
                            } else {
                                // Normal traffic - go LEFT to ALLOW
                                this.phase = 'mlGoLeft';
                                this.color = '#00ff88';
                            }
                        }
                        break;

                    // ===== NORMAL TRAFFIC: GO LEFT TO ALLOW =====
                    case 'mlGoLeft':
                        if (this.x > leftBranchX + 5) {
                            this.x -= this.speed * 1.5;
                        } else {
                            this.phase = 'mlGoDownToAllow';
                        }
                        break;

                    case 'mlGoDownToAllow':
                        this.y += this.speed;
                        if (this.y >= yPositions.allowNormal) {
                            this.phase = 'allowed';
                            stats.allowed++;
                            updateStats();
                        }
                        break;

                    // ===== ATTACK DETECTED: GO RIGHT, THEN DOWN, THEN LEFT TO XAI =====
                    case 'mlGoRight':
                        if (this.x < rightBranchX - 5) {
                            this.x += this.speed * 1.5;
                        } else {
                            this.phase = 'rightGoDownToXAI';
                        }
                        break;

                    case 'rightGoDownToXAI':
                        this.y += this.speed;
                        if (this.y >= yPositions.xai) {
                            this.phase = 'rightGoLeftToXAI';
                        }
                        break;

                    case 'rightGoLeftToXAI':
                        if (this.x > centerX + 5) {
                            this.x -= this.speed * 1.5;
                        } else {
                            this.x = centerX;
                            this.phase = 'inXAI';
                        }
                        break;

                    // ===== INSIDE XAI - GO TO MITIGATION =====
                    case 'inXAI':
                        this.y += this.speed;
                        if (this.y >= yPositions.mitigation) {
                            this.phase = 'inMitigation';
                            this.color = '#ff6b6b';
                        }
                        break;

                    // ===== INSIDE MITIGATION - GO TO UPDATE =====
                    case 'inMitigation':
                        this.y += this.speed;
                        if (this.y >= yPositions.mitigationSplit) {
                            this.phase = 'toFeedback';
                            this.color = '#00d4ff';
                            knownPatterns = Math.min(knownPatterns + 0.3, 15);
                            stats.rulesCreated++;
                            updateStats();
                        }
                        break;

                    // ===== FEEDBACK LOOP: GO LEFT, UP, THEN INTO BPF =====
                    case 'toFeedback':
                        // Go down a bit then left
                        if (this.x > 130) {
                            this.x -= this.speed * 1.2;
                            this.y += this.speed * 0.3;
                        } else {
                            this.phase = 'feedbackGoUp';
                        }
                        break;

                    case 'feedbackGoUp':
                        // Go up along left side
                        this.y -= this.speed * 2;
                        if (this.y <= yPositions.bpf + 40) {
                            this.phase = 'feedbackEnterBPF';
                        }
                        break;

                    case 'feedbackEnterBPF':
                        // Go right to enter BPF
                        if (this.x < centerX - 170) {
                            this.x += this.speed * 1.5;
                        } else {
                            this.phase = 'done';
                        }
                        break;

                    // ===== END STATES =====
                    case 'blocked':
                    case 'allowed':
                    case 'done':
                        this.alpha -= 0.025;
                        break;
                }

                return this.alpha > 0;
            }

            draw() {
                // Trail
                this.trail.forEach((t, i) => {
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, this.radius * 0.4 * (i / this.trail.length), 0, Math.PI * 2);
                    ctx.fillStyle = this.color + Math.floor(t.alpha * 40).toString(16).padStart(2, '0');
                    ctx.fill();
                });

                const pulse = 1 + Math.sin(this.pulsePhase) * 0.15;

                // Glow
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 2.5 * pulse, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 2.5 * pulse);
                gradient.addColorStop(0, this.color + '50');
                gradient.addColorStop(1, this.color + '00');
                ctx.fillStyle = gradient;
                ctx.fill();

                // Main packet
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * pulse, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.alpha;
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // Background particle
        class BgParticle {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2 + 0.5;
                this.speedY = Math.random() * 0.3 + 0.1;
                this.alpha = Math.random() * 0.15 + 0.05;
            }
            update() {
                this.y += this.speedY;
                if (this.y > canvas.height) this.reset();
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(100, 150, 255, ${this.alpha})`;
                ctx.fill();
            }
        }

        for (let i = 0; i < 50; i++) {
            bgParticles.push(new BgParticle());
        }

        // Draw a box with glow
        function drawBox(x, y, w, h, color, lines, isSmall = false) {
            ctx.shadowColor = color;
            ctx.shadowBlur = 20;

            const gradient = ctx.createLinearGradient(x - w/2, y, x - w/2, y + h);
            gradient.addColorStop(0, color + '30');
            gradient.addColorStop(1, color + '15');

            ctx.fillStyle = gradient;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.roundRect(x - w/2, y, w, h, 12);
            ctx.fill();
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            
            if (isSmall) {
                ctx.font = 'bold 18px Segoe UI';
                ctx.fillText(lines[0], x, y + h/2 + 6);
            } else {
                lines.forEach((line, i) => {
                    const offsetY = y + 28 + i * 24;
                    if (i === 0) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 17px Segoe UI';
                    } else {
                        ctx.fillStyle = '#bbb';
                        ctx.font = '14px Segoe UI';
                    }
                    ctx.fillText(line, x, offsetY);
                });
            }
        }

        // Draw vertical line with animated dots
        function drawFlowLine(x1, y1, x2, y2, color, offset = 0) {
            ctx.strokeStyle = color + '50';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            if (isRunning) {
                const dist = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
                const numDots = Math.max(2, Math.floor(dist / 50));
                for (let i = 0; i < numDots; i++) {
                    const t = ((Date.now() / 1200 + offset + i / numDots) % 1);
                    const px = x1 + (x2 - x1) * t;
                    const py = y1 + (y2 - y1) * t;

                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }
        }

        // Draw branch line
        function drawBranchLine(x1, y1, x2, y2, color, offset = 0) {
            ctx.strokeStyle = color + '50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            if (isRunning) {
                const t = ((Date.now() / 1000 + offset) % 1);
                const px = x1 + (x2 - x1) * t;
                const py = y1 + (y2 - y1) * t;
                ctx.beginPath();
                ctx.arc(px, py, 4, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            }
        }

        // Draw arrow head
        function drawArrowHead(x, y, direction, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            const size = 10;
            if (direction === 'down') {
                ctx.moveTo(x, y);
                ctx.lineTo(x - size, y - size);
                ctx.lineTo(x + size, y - size);
            } else if (direction === 'left') {
                ctx.moveTo(x, y);
                ctx.lineTo(x + size, y - size);
                ctx.lineTo(x + size, y + size);
            } else if (direction === 'up') {
                ctx.moveTo(x, y);
                ctx.lineTo(x - size, y + size);
                ctx.lineTo(x + size, y + size);
            }
            ctx.closePath();
            ctx.fill();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background particles
            bgParticles.forEach(p => {
                p.update();
                p.draw();
            });

            // ========== DRAW THE FLOW STRUCTURE ==========

            // Title
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('COMPLETE SYSTEM FLOW', centerX, 22);

            // === INTERNET / NETWORK TRAFFIC ===
            drawBox(centerX, yPositions.internet, 280, 50, '#00d4ff', ['üåê INTERNET / NETWORK TRAFFIC'], true);

            // Line: Internet ‚Üí BPF
            drawFlowLine(centerX, yPositions.internet + 50, centerX, yPositions.bpf, '#00d4ff', 0);
            drawArrowHead(centerX, yPositions.bpf, 'down', '#00d4ff');
            
            // Label
            ctx.fillStyle = '#aaa';
            ctx.font = '13px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('Incoming packets', centerX + 15, yPositions.internet + 80);

            // === PHASE 1: BPF FILTER ===
            drawBox(centerX, yPositions.bpf, 340, 85, '#00d4ff', 
                ['PHASE 1: BPF FILTER', '(The Gatekeeper)', `Known Patterns: ${Math.floor(knownPatterns)}`]);

            // Line: BPF ‚Üí Split point
            drawFlowLine(centerX, yPositions.bpf + 85, centerX, yPositions.bpfSplit, '#888', 0.1);

            // Split labels
            ctx.fillStyle = '#ff6666';
            ctx.font = 'bold 13px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('KNOWN ATTACK', leftBranchX, yPositions.bpfSplit + 18);
            ctx.font = '12px Segoe UI';
            ctx.fillText('(Pattern Match)', leftBranchX, yPositions.bpfSplit + 35);

            ctx.fillStyle = '#ffaa00';
            ctx.font = 'bold 13px Segoe UI';
            ctx.fillText('UNKNOWN TRAFFIC', rightBranchX, yPositions.bpfSplit + 18);
            ctx.font = '12px Segoe UI';
            ctx.fillText('(No Match)', rightBranchX, yPositions.bpfSplit + 35);

            // Branch: LEFT to BLOCK (red)
            drawBranchLine(centerX, yPositions.bpfSplit, leftBranchX, yPositions.bpfSplit, '#ff4444', 0.2);
            drawFlowLine(leftBranchX, yPositions.bpfSplit, leftBranchX, yPositions.blockKnown, '#ff4444', 0.25);
            drawArrowHead(leftBranchX, yPositions.blockKnown, 'down', '#ff4444');

            // Branch: RIGHT then DOWN then LEFT to ML (yellow/orange)
            drawBranchLine(centerX, yPositions.bpfSplit, rightBranchX, yPositions.bpfSplit, '#ffaa00', 0.15);
            drawFlowLine(rightBranchX, yPositions.bpfSplit, rightBranchX, yPositions.ml, '#ffaa00', 0.2);
            drawBranchLine(rightBranchX, yPositions.ml, centerX, yPositions.ml, '#ffaa00', 0.25);
            drawArrowHead(centerX, yPositions.ml, 'down', '#ffaa00');

            // === üö´ BLOCK (Known) ===
            drawBox(leftBranchX, yPositions.blockKnown, 150, 55, '#ff4444', ['üö´ BLOCK', '(Instant!)']);

            // === PHASE 2: ML MODEL ===
            drawBox(centerX, yPositions.ml, 340, 85, '#ffaa00', 
                ['PHASE 2: ML MODEL', '(The Brain)', 'Classification Engine']);

            // Line: ML ‚Üí Split
            drawFlowLine(centerX, yPositions.ml + 85, centerX, yPositions.mlSplit, '#888', 0.3);

            // ML Split labels
            ctx.fillStyle = '#00ff88';
            ctx.font = 'bold 13px Segoe UI';
            ctx.fillText('NORMAL', leftBranchX, yPositions.mlSplit + 18);
            ctx.font = '12px Segoe UI';
            ctx.fillText('TRAFFIC', leftBranchX, yPositions.mlSplit + 35);

            ctx.fillStyle = '#aa66ff';
            ctx.font = 'bold 13px Segoe UI';
            ctx.fillText('DoS ATTACK', rightBranchX, yPositions.mlSplit + 18);
            ctx.font = '12px Segoe UI';
            ctx.fillText('DETECTED', rightBranchX, yPositions.mlSplit + 35);

            // Branch: LEFT to ALLOW (green)
            drawBranchLine(centerX, yPositions.mlSplit, leftBranchX, yPositions.mlSplit, '#00ff88', 0.35);
            drawFlowLine(leftBranchX, yPositions.mlSplit, leftBranchX, yPositions.allowNormal, '#00ff88', 0.4);
            drawArrowHead(leftBranchX, yPositions.allowNormal, 'down', '#00ff88');

            // Branch: RIGHT then DOWN then LEFT to XAI (purple)
            drawBranchLine(centerX, yPositions.mlSplit, rightBranchX, yPositions.mlSplit, '#aa66ff', 0.35);
            drawFlowLine(rightBranchX, yPositions.mlSplit, rightBranchX, yPositions.xai, '#aa66ff', 0.4);
            drawBranchLine(rightBranchX, yPositions.xai, centerX, yPositions.xai, '#aa66ff', 0.45);
            drawArrowHead(centerX, yPositions.xai, 'down', '#aa66ff');

            // === ‚úÖ ALLOW ===
            drawBox(leftBranchX, yPositions.allowNormal, 150, 55, '#00ff88', ['‚úÖ ALLOW', '(Pass through)']);

            // === PHASE 3: XAI EXPLANATION ===
            drawBox(centerX, yPositions.xai, 340, 85, '#aa66ff', 
                ['PHASE 3: XAI EXPLANATION', '(The Explainer)', 'Feature Attribution Engine']);

            // Line: XAI ‚Üí Mitigation
            drawFlowLine(centerX, yPositions.xai + 85, centerX, yPositions.mitigation, '#ff6b6b', 0.5);
            drawArrowHead(centerX, yPositions.mitigation, 'down', '#ff6b6b');

            // XAI output label
            ctx.fillStyle = '#aaa';
            ctx.font = '13px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('Why it\'s DoS + Confidence', centerX + 15, yPositions.xai + 115);

            // === PHASE 4: MITIGATION ===
            drawBox(centerX, yPositions.mitigation, 340, 70, '#ff6b6b', 
                ['PHASE 4: MITIGATION', '(The Enforcer)']);

            // Mitigation outputs
            const mitOutY = yPositions.mitigationSplit;
            drawFlowLine(centerX, yPositions.mitigation + 70, centerX, mitOutY - 15, '#888', 0.55);

            // Three outputs
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 14px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText('üö´ BLOCK', centerX - 180, mitOutY + 8);
            ctx.font = '12px Segoe UI';
            ctx.fillText('Traffic', centerX - 180, mitOutY + 25);

            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 14px Segoe UI';
            ctx.fillText('üìù UPDATE', centerX, mitOutY + 8);
            ctx.font = '12px Segoe UI';
            ctx.fillText('BPF Rules', centerX, mitOutY + 25);

            ctx.fillStyle = '#ffcc00';
            ctx.font = 'bold 14px Segoe UI';
            ctx.fillText('üì¢ ALERT', centerX + 180, mitOutY + 8);
            ctx.font = '12px Segoe UI';
            ctx.fillText('Security Team', centerX + 180, mitOutY + 25);

            // Lines to three outputs
            drawBranchLine(centerX, mitOutY - 15, centerX - 180, mitOutY - 15, '#ff4444', 0.6);
            drawBranchLine(centerX, mitOutY - 15, centerX + 180, mitOutY - 15, '#ffcc00', 0.65);

            // === FEEDBACK LOOP ===
            drawFlowLine(centerX, mitOutY + 35, centerX, yPositions.feedback - 20, '#00d4ff', 0.7);

            // Curved feedback path
            ctx.strokeStyle = '#00d4ff50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX, yPositions.feedback - 20);
            ctx.lineTo(130, yPositions.feedback - 20);
            ctx.lineTo(130, yPositions.bpf + 40);
            ctx.lineTo(centerX - 170, yPositions.bpf + 40);
            ctx.stroke();
            drawArrowHead(centerX - 170, yPositions.bpf + 40, 'left', '#00d4ff');

            // Animated dots on feedback loop
            if (isRunning) {
                const pathLength = (centerX - 130) + (yPositions.feedback - 20 - yPositions.bpf - 40) + (centerX - 170 - 130);
                for (let i = 0; i < 5; i++) {
                    const t = ((Date.now() / 2500 + i * 0.2) % 1);
                    const pos = t * pathLength;
                    
                    let px, py;
                    const seg1 = centerX - 130;
                    const seg2 = yPositions.feedback - 20 - yPositions.bpf - 40;
                    const seg3 = centerX - 170 - 130;
                    
                    if (pos < seg1) {
                        px = centerX - pos;
                        py = yPositions.feedback - 20;
                    } else if (pos < seg1 + seg2) {
                        px = 130;
                        py = yPositions.feedback - 20 - (pos - seg1);
                    } else {
                        px = 130 + (pos - seg1 - seg2);
                        py = yPositions.bpf + 40;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(px, py, 5, 0, Math.PI * 2);
                    ctx.fillStyle = '#00d4ff';
                    ctx.fill();
                }
            }

            // Feedback label
            ctx.fillStyle = '#00d4ff';
            ctx.font = 'bold 13px Segoe UI';
            ctx.textAlign = 'left';
            ctx.fillText('Back to Phase 1 ‚óÑ', 145, yPositions.bpf + 65);
            ctx.font = '12px Segoe UI';
            ctx.fillStyle = '#aaa';
            ctx.fillText('(BPF now knows this pattern!)', 145, yPositions.bpf + 85);

            // Draw all packets
            packets.forEach(packet => packet.draw());

            // Attack mode indicator
            if (attackMode) {
                ctx.fillStyle = '#ff4444';
                ctx.font = 'bold 18px Segoe UI';
                ctx.textAlign = 'center';
                ctx.fillText('‚ö†Ô∏è ATTACK WAVE IN PROGRESS ‚ö†Ô∏è', centerX, yPositions.internet + 75);
            }
        }

        function update() {
            if (!isRunning) return;

            packets = packets.filter(p => p.update());

            if (Math.random() < (attackMode ? 0.1 : 0.035)) {
                packets.push(new Packet());
            }

            if (attackMode) {
                attackModeTimer--;
                if (attackModeTimer <= 0) {
                    attackMode = false;
                }
            }
        }

        function updateStats() {
            document.getElementById('totalPackets').textContent = stats.totalPackets;
            document.getElementById('bpfBlocked').textContent = stats.bpfBlocked;
            document.getElementById('mlDetected').textContent = stats.mlDetected;
            document.getElementById('allowed').textContent = stats.allowed;
            document.getElementById('rulesCreated').textContent = stats.rulesCreated;
        }

        function toggleAnimation() {
            isRunning = !isRunning;
        }

        function simulateAttack() {
            attackMode = true;
            attackModeTimer = 300;
        }

        function resetStats() {
            stats = { totalPackets: 0, bpfBlocked: 0, mlDetected: 0, allowed: 0, rulesCreated: 0 };
            knownPatterns = 2;
            packets = [];
            updateStats();
        }

        function animate() {
            update();
            draw();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
